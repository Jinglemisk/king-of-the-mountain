rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(room) {
      return room.data.ownerUid == request.auth.uid;
    }

    function isInRoom(room) {
      return room.data.seats[0].uid == request.auth.uid ||
             room.data.seats[1].uid == request.auth.uid ||
             room.data.seats[2].uid == request.auth.uid ||
             room.data.seats[3].uid == request.auth.uid ||
             room.data.seats[4].uid == request.auth.uid ||
             room.data.seats[5].uid == request.auth.uid;
    }

    function isCurrentPlayer(game) {
      return game.data.currentPlayerUid == request.auth.uid;
    }

    function isValidVersionIncrement(game) {
      return request.resource.data.version == resource.data.version + 1;
    }

    function isValidSeatUpdate(room) {
      // Check that only the user's own seat is being modified
      // This is simplified - in production, would need more detailed validation
      return request.resource.data.seats.size() == 6;
    }

    function isInGame(gameId) {
      let game = get(/databases/$(database)/documents/games/$(gameId));
      return request.auth.uid in game.data.players;
    }

    // Rooms collection
    match /rooms/{roomCode} {
      allow read: if isAuthenticated();

      allow create: if isAuthenticated() &&
        request.resource.data.ownerUid == request.auth.uid &&
        request.resource.data.code == roomCode &&
        roomCode.size() == 6;

      allow update: if isAuthenticated() && (
        // Owner can update most fields
        isOwner(resource) ||
        // Players can update their own seat
        (isInRoom(resource) && isValidSeatUpdate(resource)) ||
        // Any authenticated user can claim an empty seat
        (!isInRoom(resource) && request.resource.data.seats.size() == 6)
      );

      allow delete: if isOwner(resource) &&
        resource.data.status == 'ended';
    }

    // Games collection
    match /games/{gameId} {
      allow read: if isAuthenticated() &&
        request.auth.uid in resource.data.players;

      allow create: if isAuthenticated() &&
        request.resource.data.createdBy == request.auth.uid &&
        request.resource.data.version == 1;

      allow update: if isAuthenticated() && (
        // Current player can update during their turn
        (isCurrentPlayer(resource) &&
         resource.data.status == 'playing' &&
         isValidVersionIncrement(resource)) ||
        // Owner can end the game
        (request.resource.data.createdBy == request.auth.uid &&
         request.resource.data.status == 'ended' &&
         resource.data.status == 'playing')
      );

      allow delete: if false; // Never allow deletion

      // Log subcollection
      match /log/{logId} {
        allow read: if isAuthenticated() && isInGame(gameId);
        allow create: if isAuthenticated() && isInGame(gameId);
        allow update: if false;
        allow delete: if false;
      }

      // Chat subcollection
      match /chat/{chatId} {
        allow read: if isAuthenticated() && isInGame(gameId);
        allow create: if isAuthenticated() &&
          isInGame(gameId) &&
          request.resource.data.uid == request.auth.uid;
        allow update: if request.auth.uid == resource.data.uid &&
          // Allow editing own messages within 2 minutes
          request.time < resource.data.ts + duration.value(2, 'm');
        allow delete: if false;
      }

      // Actions subcollection
      match /actions/{actionId} {
        allow read: if isAuthenticated() && isInGame(gameId);
        allow create: if isAuthenticated() &&
          isInGame(gameId) &&
          request.resource.data.uid == request.auth.uid;
        allow update: if false;
        allow delete: if false;
      }
    }
  }
}